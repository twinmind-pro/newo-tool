package llm

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/twinmind/newo-tool/internal/config"

	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

// LLMClient is an interface for LLM clients.
type LLMClient interface {
	GenerateCode(prompt string) (string, error)
}

// NewClient creates a new LLM client based on configuration.
func NewClient(cfg config.LLMConfig) (LLMClient, error) {
	switch cfg.Provider {
	case "gemini":
		return NewGeminiClient(cfg)
	case "vertexai":
		return nil, fmt.Errorf("vertex AI integration not yet implemented")
	case "deepseek":
		return nil, fmt.Errorf("DeepSeek integration not yet implemented")
	default:
		return nil, fmt.Errorf("unsupported LLM provider: %s", cfg.Provider)
	}
}

// GeminiClient implements LLMClient for Google Gemini API.
type GeminiClient struct {
	client *genai.Client
	model  *genai.GenerativeModel
}

// NewGeminiClient creates a new GeminiClient.
func NewGeminiClient(cfg config.LLMConfig) (*GeminiClient, error) {
	if cfg.APIKey == "" {
		return nil, fmt.Errorf("gemini API key is not configured")
	}

	ctx := context.Background()
	client, err := genai.NewClient(ctx, option.WithAPIKey(cfg.APIKey))
	if err != nil {
		return nil, fmt.Errorf("failed to create Gemini client: %w", err)
	}

	gClient := &GeminiClient{client: client}

	model := client.GenerativeModel(cfg.Model)
	if model == nil {
		return nil, fmt.Errorf("failed to get Gemini model: %s", cfg.Model)
	}

	gClient.model = model
	return gClient, nil
}

var jsonCodeBlockRegex = regexp.MustCompile("(?s)```json\n(.*?)\n```")

// GenerateCode makes an actual API call to Gemini to generate code.
func (c *GeminiClient) GenerateCode(prompt string) (string, error) {
	ctx := context.Background()

	resp, err := c.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return "", fmt.Errorf("failed to generate content from Gemini: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("no content generated by Gemini")
	}

	// Assuming the LLM returns a single text part containing the JSON AST
	part, ok := resp.Candidates[0].Content.Parts[0].(genai.Text)
	if !ok {
		return "", fmt.Errorf("expected text content from Gemini, got %T", resp.Candidates[0].Content.Parts[0])
	}

	rawResponse := string(part)

	// Extract JSON from Markdown code block
	matches := jsonCodeBlockRegex.FindStringSubmatch(rawResponse)
	if len(matches) > 1 {
		return strings.TrimSpace(matches[1]), nil
	}

	// If no Markdown code block is found, assume the response is pure JSON
	return strings.TrimSpace(rawResponse), nil
}